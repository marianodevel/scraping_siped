============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/mariano/scraping_siped/.venv/bin/python3
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.17.7-arch1-1-x86_64-with-glibc2.42', 'Packages': {'pytest': '8.4.2', 'pluggy': '1.6.0'}, 'Plugins': {'variables': '3.1.0', 'flask': '1.3.0', 'pyfakefs': '5.10.2', 'metadata': '3.1.1', 'html': '4.1.1', 'selenium': '4.1.0', 'base-url': '2.1.0', 'mock': '3.15.1'}, 'Base URL': '', 'Driver': None, 'Capabilities': {}}
sensitiveurl: .*
rootdir: /home/mariano/scraping_siped
configfile: pytest.ini
plugins: variables-3.1.0, flask-1.3.0, pyfakefs-5.10.2, metadata-3.1.1, html-4.1.1, selenium-4.1.0, base-url-2.1.0, mock-3.15.1
collecting ... collected 24 items

tests/e2e/test_app.py::test_login_get PASSED                             [  4%]
tests/e2e/test_app.py::test_login_post_fallido PASSED                    [  8%]
tests/e2e/test_app.py::test_login_post_exitoso_y_logout FAILED           [ 12%]
tests/e2e/test_app.py::test_rutas_protegidas_sin_login PASSED            [ 16%]
tests/e2e/test_app.py::test_iniciar_fase PASSED                          [ 20%]
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase ERROR       [ 25%]
tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling ERROR [ 29%]
tests/e2e/test_frontend.py::test_race_condition_doble_clic ERROR         [ 33%]
tests/integration/test_fases.py::test_ejecutar_fase_1_exito FAILED       [ 37%]
tests/integration/test_fases.py::test_ejecutar_fase_1_sin_expedientes FAILED [ 41%]
tests/integration/test_fases.py::test_ejecutar_fase_2 FAILED             [ 45%]
tests/integration/test_gestor_almacenamiento.py::test_listar_archivos_pdf PASSED [ 50%]
tests/integration/test_gestor_tareas.py::test_registrar_y_obtener_id PASSED [ 54%]
tests/integration/test_gestor_tareas.py::test_resetear_id_tarea PASSED   [ 58%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_exitosa PASSED [ 62%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_pendiente PASSED [ 66%]
tests/unit/test_parsers.py::test_obtener_url_meta_refresh PASSED         [ 70%]
tests/unit/test_parsers.py::test_obtener_enlace_token_siped PASSED       [ 75%]
tests/unit/test_parsers.py::test_parsear_lista_expedientes PASSED        [ 79%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_inicio PASSED [ 83%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_fin PASSED   [ 87%]
tests/unit/test_parsers.py::test_parsear_detalle_para_ajax_params PASSED [ 91%]
tests/unit/test_parsers.py::test_parsear_movimientos_de_ajax_html PASSED [ 95%]
tests/unit/test_parsers.py::test_parsear_pagina_documento PASSED         [100%]

==================================== ERRORS ====================================
______________ ERROR at setup of test_flujo_login_y_arrancar_fase ______________
ScopeMismatch: You tried to access the function scoped fixture app with a session scoped request object. Requesting fixture stack:
.venv/lib/python3.13/site-packages/pytest_flask/fixtures.py:40:  def live_server(request, app, pytestconfig)
Requested fixture:
tests/conftest.py:163:  def app()
__________ ERROR at setup of test_flujo_completo_de_estado_ui_polling __________
ScopeMismatch: You tried to access the function scoped fixture app with a session scoped request object. Requesting fixture stack:
.venv/lib/python3.13/site-packages/pytest_flask/fixtures.py:40:  def live_server(request, app, pytestconfig)
Requested fixture:
tests/conftest.py:163:  def app()
_______________ ERROR at setup of test_race_condition_doble_clic _______________
ScopeMismatch: You tried to access the function scoped fixture app with a session scoped request object. Requesting fixture stack:
.venv/lib/python3.13/site-packages/pytest_flask/fixtures.py:40:  def live_server(request, app, pytestconfig)
Requested fixture:
tests/conftest.py:163:  def app()
=================================== FAILURES ===================================
_______________________ test_login_post_exitoso_y_logout _______________________

client = <FlaskClient <Flask 'app'>>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f28c5190050>

    def test_login_post_exitoso_y_logout(client, mocker):
        """Prueba un login exitoso, la sesión y el logout."""
    
        # Simulamos que la autenticación tiene éxito
        fake_cookies = {"JSESSIONID": "abc12345"}
        mocker.patch("app.session_manager.autenticar_en_siped", return_value=fake_cookies)
    
        # 1. Hacemos LOGIN
        response = client.post(
            "/login",
            data={"username": "good_user", "password": "good_password"},
            follow_redirects=True,
        )
    
        # Verifica que se redirige al índice
        assert response.status_code == 200
        assert b"Bienvenido, good_user!" in response.data  # Mensaje flash
    
        # Verifica que la sesión de Flask ahora tiene las cookies
        # (Necesitamos 'with client.session_transaction()' si no usamos follow_redirects)
    
        # 2. Probamos una RUTA PROTEGIDA (el índice)
        response = client.get("/")
        assert response.status_code == 200
>       assert b"Estado Fase 1" in response.data
E       assert b'Estado Fase 1' in b'<!DOCTYPE html>\n<html lang="es">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Scraper de Expedientes - Flask/Celery</title>\n    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.css">\n    <script src="https://unpkg.com/htmx.org@1.9.10" defer></script> \n    <style>\n        body { max-width: 1000px; margin: auto; padding: 1rem; }\n        .fase-container { \n            border: 1px solid var(--border-color);\n            padding: 1.5rem;\n            margin-bottom: 2rem;\n            border-radius: 8px;\n            background: var(--background-alt);\n        }\n        .fase-control { \n            display: flex;\n            align-items: center;\n            justify-content: space-between;\n        }\n        .status-badge {\n            padding: 0.2rem 0.5rem;\n            border-radius: 4px;\n            font-weight: bold;\n            font-size: 0.9em;\n            color: #333; \n            min-width: 80px; \n            text-align: center;\n        }\n        .status-PENDING, .status-RETRY { background-color: #ffc107; } \n        .status-STARTED { background-col...t) {\n            \n            // 1. Si se actualiz\xc3\xb3 un contenedor de estado:\n            if (evt.target.id && evt.target.id.startsWith(\'estado-resultado-\')) {\n                const badge = evt.target.querySelector(\'.status-badge\');\n                if (!badge) return;\n\n                const status = badge.textContent.trim();\n                \n                // Si el estado es FINAL (SUCCESS o FAILURE, pero no IDLE)\n                if ([\'SUCCESS\', \'FAILURE\', \'REVOKED\'].includes(status) && status !== \'IDLE\') {\n                    // Disparamos el evento global\n                    document.body.dispatchEvent(new Event(\'tareaFinalizada\'));\n\n                    // Forzamos el desbloqueo del bot\xc3\xb3n\n                    const faseId = evt.target.id.replace(\'estado-resultado-\', \'\');\n                    const button = document.querySelector(`button[data-fase="${faseId}"]`);\n                    if (button) {\n                        button.disabled = false;\n                        button.textContent = `Iniciar Fase ${faseId.split(\'_\')[1]}`;\n                    }\n                }\n            }\n        });\n    </script>\n</body>\n</html>'
E        +  where b'<!DOCTYPE html>\n<html lang="es">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Scraper de Expedientes - Flask/Celery</title>\n    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.css">\n    <script src="https://unpkg.com/htmx.org@1.9.10" defer></script> \n    <style>\n        body { max-width: 1000px; margin: auto; padding: 1rem; }\n        .fase-container { \n            border: 1px solid var(--border-color);\n            padding: 1.5rem;\n            margin-bottom: 2rem;\n            border-radius: 8px;\n            background: var(--background-alt);\n        }\n        .fase-control { \n            display: flex;\n            align-items: center;\n            justify-content: space-between;\n        }\n        .status-badge {\n            padding: 0.2rem 0.5rem;\n            border-radius: 4px;\n            font-weight: bold;\n            font-size: 0.9em;\n            color: #333; \n            min-width: 80px; \n            text-align: center;\n        }\n        .status-PENDING, .status-RETRY { background-color: #ffc107; } \n        .status-STARTED { background-col...t) {\n            \n            // 1. Si se actualiz\xc3\xb3 un contenedor de estado:\n            if (evt.target.id && evt.target.id.startsWith(\'estado-resultado-\')) {\n                const badge = evt.target.querySelector(\'.status-badge\');\n                if (!badge) return;\n\n                const status = badge.textContent.trim();\n                \n                // Si el estado es FINAL (SUCCESS o FAILURE, pero no IDLE)\n                if ([\'SUCCESS\', \'FAILURE\', \'REVOKED\'].includes(status) && status !== \'IDLE\') {\n                    // Disparamos el evento global\n                    document.body.dispatchEvent(new Event(\'tareaFinalizada\'));\n\n                    // Forzamos el desbloqueo del bot\xc3\xb3n\n                    const faseId = evt.target.id.replace(\'estado-resultado-\', \'\');\n                    const button = document.querySelector(`button[data-fase="${faseId}"]`);\n                    if (button) {\n                        button.disabled = false;\n                        button.textContent = `Iniciar Fase ${faseId.split(\'_\')[1]}`;\n                    }\n                }\n            }\n        });\n    </script>\n</body>\n</html>' = <WrapperTestResponse 8156 bytes [200 OK]>.data

tests/e2e/test_app.py:55: AssertionError
----------------------------- Captured stdout call -----------------------------
Intentando autenticar a good_user...
__________________________ test_ejecutar_fase_1_exito __________________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f28c5107820>

    def test_ejecutar_fase_1_exito(mocker):
        """Prueba el flujo exitoso de la Fase 1."""
    
        # 1. Datos simulados que devolverá el scraper
        datos_simulados = [
            {"expediente": "EXP-100/2025", "caratula": "PEREZ..."},
            {"expediente": "EXP-101/2025", "caratula": "GOMEZ..."},
        ]
    
        # 2. Mockear las dependencias
        # No necesitamos 'session' real, pero el decorador la crea.
        # Simulamos 'raspar_lista_expedientes' para que devuelva nuestros datos.
        mock_scraper = mocker.patch(
            "fases.fase_1.scraper_tasks.raspar_lista_expedientes",
            return_value=datos_simulados,
        )
    
        # Simulamos 'guardar_a_csv' para espiar si se llama correctamente.
        mock_guardar = mocker.patch("fases.fase_1.utils.guardar_a_csv")
    
        # Simulamos el decorador para que no intente crear una sesión real
        # (También podríamos mockear 'session_manager.crear_sesion_con_cookies')
>       mocker.patch(
            "fases.fase_1.session_manager.crear_sesion_con_cookies",
            return_value=mocker.Mock(),
        )

tests/integration/test_fases.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/pytest_mock/plugin.py:448: in __call__
    return self._start_patch(
.venv/lib/python3.13/site-packages/pytest_mock/plugin.py:266: in _start_patch
    mocked: MockType = p.start()
                       ^^^^^^^^^
/usr/lib/python3.13/unittest/mock.py:1654: in start
    result = self.__enter__()
             ^^^^^^^^^^^^^^^^
/usr/lib/python3.13/unittest/mock.py:1481: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'fases.fase_1.session_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'fases.fase_1' has no attribute 'session_manager'

/usr/lib/python3.13/pkgutil.py:528: AttributeError
_____________________ test_ejecutar_fase_1_sin_expedientes _____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f28c5107360>

    def test_ejecutar_fase_1_sin_expedientes(mocker):
        """Prueba qué pasa si el scraper no devuelve nada."""
    
        # 1. Scraper devuelve lista vacía
        mock_scraper = mocker.patch(
            "fases.fase_1.scraper_tasks.raspar_lista_expedientes", return_value=[]
        )
        mock_guardar = mocker.patch("fases.fase_1.utils.guardar_a_csv")
>       mocker.patch(
            "fases.fase_1.session_manager.crear_sesion_con_cookies",
            return_value=mocker.Mock(),
        )

tests/integration/test_fases.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/pytest_mock/plugin.py:448: in __call__
    return self._start_patch(
.venv/lib/python3.13/site-packages/pytest_mock/plugin.py:266: in _start_patch
    mocked: MockType = p.start()
                       ^^^^^^^^^
/usr/lib/python3.13/unittest/mock.py:1654: in start
    result = self.__enter__()
             ^^^^^^^^^^^^^^^^
/usr/lib/python3.13/unittest/mock.py:1481: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'fases.fase_1.session_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'fases.fase_1' has no attribute 'session_manager'

/usr/lib/python3.13/pkgutil.py:528: AttributeError
_____________________________ test_ejecutar_fase_2 _____________________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f28c5181b50>
fs = <pyfakefs.fake_filesystem.FakeFilesystem object at 0x7f28c5197b60>

    def test_ejecutar_fase_2(mocker, fs):
        """Prueba el flujo de la Fase 2 usando un sistema de archivos falso."""
    
        # 1. Datos simulados (lista de expedientes leída de CSV)
        lista_expedientes_csv = [
            {"expediente": "EXP-100", "caratula": "PEREZ"},
            {"expediente": "EXP-200", "caratula": "GOMEZ (YA EXISTE)"},
        ]
    
        # 2. Movimientos simulados (devueltos por el scraper)
        movimientos_exp_100 = [{"nombre_escrito": "Mov 1"}, {"nombre_escrito": "Mov 2"}]
    
        # 3. Crear el CSV falso de la Fase 1 (fs)
        # (Necesitaríamos la función 'guardar_a_csv' real o simularla aquí)
        # Por simplicidad, simulamos 'leer_csv_a_diccionario'
        mocker.patch(
            "fases.fase_2.utils.leer_csv_a_diccionario", return_value=lista_expedientes_csv
        )
    
        # 4. Crear un archivo CSV de movimientos "existente"
        fs.create_dir(config.MOVIMIENTOS_OUTPUT_DIR)
        ruta_existente = f"{config.MOVIMIENTOS_OUTPUT_DIR}/EXP-200 - GOMEZ (YA EXISTE).csv"
        fs.create_file(ruta_existente)
    
        # 5. Mockear el scraper de movimientos
        mock_scraper_mov = mocker.patch(
            "fases.fase_2.scraper_tasks.raspar_movimientos_de_expediente",
            return_value=movimientos_exp_100,
        )
    
        # 6. Mockear el guardado de CSV
        mock_guardar = mocker.patch("fases.fase_2.utils.guardar_a_csv")
>       mocker.patch(
            "fases.fase_2.session_manager.crear_sesion_con_cookies",
            return_value=mocker.Mock(),
        )

/home/mariano/scraping_siped/tests/integration/test_fases.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/mariano/scraping_siped/.venv/lib/python3.13/site-packages/pytest_mock/plugin.py:448: in __call__
    return self._start_patch(
/home/mariano/scraping_siped/.venv/lib/python3.13/site-packages/pytest_mock/plugin.py:266: in _start_patch
    mocked: MockType = p.start()
                       ^^^^^^^^^
/usr/lib/python3.13/unittest/mock.py:1654: in start
    result = self.__enter__()
             ^^^^^^^^^^^^^^^^
/usr/lib/python3.13/unittest/mock.py:1481: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'fases.fase_2.session_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'fases.fase_2' has no attribute 'session_manager'

/usr/lib/python3.13/pkgutil.py:528: AttributeError
=========================== short test summary info ============================
FAILED tests/e2e/test_app.py::test_login_post_exitoso_y_logout - assert b'Est...
FAILED tests/integration/test_fases.py::test_ejecutar_fase_1_exito - Attribut...
FAILED tests/integration/test_fases.py::test_ejecutar_fase_1_sin_expedientes
FAILED tests/integration/test_fases.py::test_ejecutar_fase_2 - AttributeError...
ERROR tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase - Failed: ...
ERROR tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling - ...
ERROR tests/e2e/test_frontend.py::test_race_condition_doble_clic - Failed: Sc...
==================== 4 failed, 17 passed, 3 errors in 0.21s ====================
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/mariano/scraping_siped/.venv/bin/python3
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.17.7-arch1-1-x86_64-with-glibc2.42', 'Packages': {'pytest': '8.4.2', 'pluggy': '1.6.0'}, 'Plugins': {'variables': '3.1.0', 'flask': '1.3.0', 'pyfakefs': '5.10.2', 'metadata': '3.1.1', 'html': '4.1.1', 'selenium': '4.1.0', 'base-url': '2.1.0', 'mock': '3.15.1'}, 'Base URL': '', 'Driver': None, 'Capabilities': {}}
sensitiveurl: .*
rootdir: /home/mariano/scraping_siped
configfile: pytest.ini
plugins: variables-3.1.0, flask-1.3.0, pyfakefs-5.10.2, metadata-3.1.1, html-4.1.1, selenium-4.1.0, base-url-2.1.0, mock-3.15.1
collecting ... collected 24 items

tests/e2e/test_app.py::test_login_get PASSED                             [  4%]
tests/e2e/test_app.py::test_login_post_fallido PASSED                    [  8%]
tests/e2e/test_app.py::test_login_post_exitoso_y_logout PASSED           [ 12%]
tests/e2e/test_app.py::test_rutas_protegidas_sin_login PASSED            [ 16%]
tests/e2e/test_app.py::test_iniciar_fase PASSED                          [ 20%]
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase ERROR       [ 25%]
tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling ERROR [ 29%]
tests/e2e/test_frontend.py::test_race_condition_doble_clic ERROR         [ 33%]
tests/integration/test_fases.py::test_ejecutar_fase_1_exito PASSED       [ 37%]
tests/integration/test_fases.py::test_ejecutar_fase_1_sin_expedientes PASSED [ 41%]
tests/integration/test_fases.py::test_ejecutar_fase_2 PASSED             [ 45%]
tests/integration/test_gestor_almacenamiento.py::test_listar_archivos_pdf PASSED [ 50%]
tests/integration/test_gestor_tareas.py::test_registrar_y_obtener_id PASSED [ 54%]
tests/integration/test_gestor_tareas.py::test_resetear_id_tarea PASSED   [ 58%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_exitosa PASSED [ 62%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_pendiente PASSED [ 66%]
tests/unit/test_parsers.py::test_obtener_url_meta_refresh PASSED         [ 70%]
tests/unit/test_parsers.py::test_obtener_enlace_token_siped PASSED       [ 75%]
tests/unit/test_parsers.py::test_parsear_lista_expedientes PASSED        [ 79%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_inicio PASSED [ 83%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_fin PASSED   [ 87%]
tests/unit/test_parsers.py::test_parsear_detalle_para_ajax_params PASSED [ 91%]
tests/unit/test_parsers.py::test_parsear_movimientos_de_ajax_html PASSED [ 95%]
tests/unit/test_parsers.py::test_parsear_pagina_documento PASSED         [100%]

==================================== ERRORS ====================================
______________ ERROR at setup of test_flujo_login_y_arrancar_fase ______________
ScopeMismatch: You tried to access the function scoped fixture app with a session scoped request object. Requesting fixture stack:
.venv/lib/python3.13/site-packages/pytest_flask/fixtures.py:40:  def live_server(request, app, pytestconfig)
Requested fixture:
tests/conftest.py:163:  def app()
__________ ERROR at setup of test_flujo_completo_de_estado_ui_polling __________
ScopeMismatch: You tried to access the function scoped fixture app with a session scoped request object. Requesting fixture stack:
.venv/lib/python3.13/site-packages/pytest_flask/fixtures.py:40:  def live_server(request, app, pytestconfig)
Requested fixture:
tests/conftest.py:163:  def app()
_______________ ERROR at setup of test_race_condition_doble_clic _______________
ScopeMismatch: You tried to access the function scoped fixture app with a session scoped request object. Requesting fixture stack:
.venv/lib/python3.13/site-packages/pytest_flask/fixtures.py:40:  def live_server(request, app, pytestconfig)
Requested fixture:
tests/conftest.py:163:  def app()
=========================== short test summary info ============================
ERROR tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase - Failed: ...
ERROR tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling - ...
ERROR tests/e2e/test_frontend.py::test_race_condition_doble_clic - Failed: Sc...
========================= 21 passed, 3 errors in 0.09s =========================
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/mariano/scraping_siped/.venv/bin/python3
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.17.7-arch1-1-x86_64-with-glibc2.42', 'Packages': {'pytest': '8.4.2', 'pluggy': '1.6.0'}, 'Plugins': {'variables': '3.1.0', 'flask': '1.3.0', 'pyfakefs': '5.10.2', 'metadata': '3.1.1', 'html': '4.1.1', 'selenium': '4.1.0', 'base-url': '2.1.0', 'mock': '3.15.1'}, 'Base URL': '', 'Driver': None, 'Capabilities': {}}
sensitiveurl: .*
rootdir: /home/mariano/scraping_siped
configfile: pytest.ini
plugins: variables-3.1.0, flask-1.3.0, pyfakefs-5.10.2, metadata-3.1.1, html-4.1.1, selenium-4.1.0, base-url-2.1.0, mock-3.15.1
collecting ... collected 24 items

tests/e2e/test_app.py::test_login_get PASSED                             [  4%]
tests/e2e/test_app.py::test_login_post_fallido PASSED                    [  8%]
tests/e2e/test_app.py::test_login_post_exitoso_y_logout PASSED           [ 12%]
tests/e2e/test_app.py::test_rutas_protegidas_sin_login PASSED            [ 16%]
tests/e2e/test_app.py::test_iniciar_fase PASSED                          [ 20%]
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase ERROR       [ 25%]
tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling ERROR [ 29%]
tests/e2e/test_frontend.py::test_race_condition_doble_clic ERROR         [ 33%]
tests/integration/test_fases.py::test_ejecutar_fase_1_exito PASSED       [ 37%]
tests/integration/test_fases.py::test_ejecutar_fase_1_sin_expedientes PASSED [ 41%]
tests/integration/test_fases.py::test_ejecutar_fase_2 PASSED             [ 45%]
tests/integration/test_gestor_almacenamiento.py::test_listar_archivos_pdf PASSED [ 50%]
tests/integration/test_gestor_tareas.py::test_registrar_y_obtener_id PASSED [ 54%]
tests/integration/test_gestor_tareas.py::test_resetear_id_tarea PASSED   [ 58%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_exitosa PASSED [ 62%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_pendiente PASSED [ 66%]
tests/unit/test_parsers.py::test_obtener_url_meta_refresh PASSED         [ 70%]
tests/unit/test_parsers.py::test_obtener_enlace_token_siped PASSED       [ 75%]
tests/unit/test_parsers.py::test_parsear_lista_expedientes PASSED        [ 79%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_inicio PASSED [ 83%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_fin PASSED   [ 87%]
tests/unit/test_parsers.py::test_parsear_detalle_para_ajax_params PASSED [ 91%]
tests/unit/test_parsers.py::test_parsear_movimientos_de_ajax_html PASSED [ 95%]
tests/unit/test_parsers.py::test_parsear_pagina_documento PASSED         [100%]

==================================== ERRORS ====================================
______________ ERROR at setup of test_flujo_login_y_arrancar_fase ______________

request = <SubRequest 'driver_class' for <Function test_flujo_login_y_arrancar_fase>>

    @pytest.fixture(scope="session")
    def driver_class(request):
        driver = request.config.getoption("driver")
        if driver is None:
>           raise pytest.UsageError("--driver must be specified")
E           _pytest.config.exceptions.UsageError: --driver must be specified

.venv/lib/python3.13/site-packages/pytest_selenium/pytest_selenium.py:156: UsageError
---------------------------- Captured stdout setup -----------------------------
 * Serving Flask app 'app'
 * Debug mode: off
__________ ERROR at setup of test_flujo_completo_de_estado_ui_polling __________

request = <SubRequest 'driver_class' for <Function test_flujo_login_y_arrancar_fase>>

    @pytest.fixture(scope="session")
    def driver_class(request):
        driver = request.config.getoption("driver")
        if driver is None:
>           raise pytest.UsageError("--driver must be specified")
E           _pytest.config.exceptions.UsageError: --driver must be specified

.venv/lib/python3.13/site-packages/pytest_selenium/pytest_selenium.py:156: UsageError
_______________ ERROR at setup of test_race_condition_doble_clic _______________

request = <SubRequest 'driver_class' for <Function test_flujo_login_y_arrancar_fase>>

    @pytest.fixture(scope="session")
    def driver_class(request):
        driver = request.config.getoption("driver")
        if driver is None:
>           raise pytest.UsageError("--driver must be specified")
E           _pytest.config.exceptions.UsageError: --driver must be specified

.venv/lib/python3.13/site-packages/pytest_selenium/pytest_selenium.py:156: UsageError
=========================== short test summary info ============================
ERROR tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase - _pytest....
ERROR tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling - ...
ERROR tests/e2e/test_frontend.py::test_race_condition_doble_clic - _pytest.co...
========================= 21 passed, 3 errors in 0.14s =========================
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/mariano/scraping_siped/.venv/bin/python3
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.17.7-arch1-1-x86_64-with-glibc2.42', 'Packages': {'pytest': '8.4.2', 'pluggy': '1.6.0'}, 'Plugins': {'variables': '3.1.0', 'flask': '1.3.0', 'pyfakefs': '5.10.2', 'metadata': '3.1.1', 'html': '4.1.1', 'selenium': '4.1.0', 'base-url': '2.1.0', 'mock': '3.15.1'}, 'Base URL': '', 'Driver': None, 'Capabilities': {}}
sensitiveurl: .*
rootdir: /home/mariano/scraping_siped
configfile: pytest.ini
plugins: variables-3.1.0, flask-1.3.0, pyfakefs-5.10.2, metadata-3.1.1, html-4.1.1, selenium-4.1.0, base-url-2.1.0, mock-3.15.1
collecting ... collected 24 items

tests/e2e/test_app.py::test_login_get PASSED                             [  4%]
tests/e2e/test_app.py::test_login_post_fallido PASSED                    [  8%]
tests/e2e/test_app.py::test_login_post_exitoso_y_logout PASSED           [ 12%]
tests/e2e/test_app.py::test_rutas_protegidas_sin_login PASSED            [ 16%]
tests/e2e/test_app.py::test_iniciar_fase PASSED                          [ 20%]
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase ERROR       [ 25%]
tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling ERROR [ 29%]
tests/e2e/test_frontend.py::test_race_condition_doble_clic ERROR         [ 33%]
tests/integration/test_fases.py::test_ejecutar_fase_1_exito PASSED       [ 37%]
tests/integration/test_fases.py::test_ejecutar_fase_1_sin_expedientes PASSED [ 41%]
tests/integration/test_fases.py::test_ejecutar_fase_2 PASSED             [ 45%]
tests/integration/test_gestor_almacenamiento.py::test_listar_archivos_pdf PASSED [ 50%]
tests/integration/test_gestor_tareas.py::test_registrar_y_obtener_id PASSED [ 54%]
tests/integration/test_gestor_tareas.py::test_resetear_id_tarea PASSED   [ 58%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_exitosa PASSED [ 62%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_pendiente PASSED [ 66%]
tests/unit/test_parsers.py::test_obtener_url_meta_refresh PASSED         [ 70%]
tests/unit/test_parsers.py::test_obtener_enlace_token_siped PASSED       [ 75%]
tests/unit/test_parsers.py::test_parsear_lista_expedientes PASSED        [ 79%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_inicio PASSED [ 83%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_fin PASSED   [ 87%]
tests/unit/test_parsers.py::test_parsear_detalle_para_ajax_params PASSED [ 91%]
tests/unit/test_parsers.py::test_parsear_movimientos_de_ajax_html PASSED [ 95%]
tests/unit/test_parsers.py::test_parsear_pagina_documento PASSED         [100%]

==================================== ERRORS ====================================
______________ ERROR at setup of test_flujo_login_y_arrancar_fase ______________

request = <SubRequest 'driver_class' for <Function test_flujo_login_y_arrancar_fase>>

    @pytest.fixture(scope="session")
    def driver_class(request):
        driver = request.config.getoption("driver")
        if driver is None:
>           raise pytest.UsageError("--driver must be specified")
E           _pytest.config.exceptions.UsageError: --driver must be specified

.venv/lib/python3.13/site-packages/pytest_selenium/pytest_selenium.py:156: UsageError
---------------------------- Captured stdout setup -----------------------------
 * Serving Flask app 'app'
 * Debug mode: off
__________ ERROR at setup of test_flujo_completo_de_estado_ui_polling __________

request = <SubRequest 'driver_class' for <Function test_flujo_login_y_arrancar_fase>>

    @pytest.fixture(scope="session")
    def driver_class(request):
        driver = request.config.getoption("driver")
        if driver is None:
>           raise pytest.UsageError("--driver must be specified")
E           _pytest.config.exceptions.UsageError: --driver must be specified

.venv/lib/python3.13/site-packages/pytest_selenium/pytest_selenium.py:156: UsageError
_______________ ERROR at setup of test_race_condition_doble_clic _______________

request = <SubRequest 'driver_class' for <Function test_flujo_login_y_arrancar_fase>>

    @pytest.fixture(scope="session")
    def driver_class(request):
        driver = request.config.getoption("driver")
        if driver is None:
>           raise pytest.UsageError("--driver must be specified")
E           _pytest.config.exceptions.UsageError: --driver must be specified

.venv/lib/python3.13/site-packages/pytest_selenium/pytest_selenium.py:156: UsageError
=============================== warnings summary ===============================
.venv/lib/python3.13/site-packages/_pytest/config/__init__.py:1474
  /home/mariano/scraping_siped/.venv/lib/python3.13/site-packages/_pytest/config/__init__.py:1474: PytestConfigWarning: Unknown config option: driver
  
    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase - _pytest....
ERROR tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling - ...
ERROR tests/e2e/test_frontend.py::test_race_condition_doble_clic - _pytest.co...
=================== 21 passed, 1 warning, 3 errors in 0.14s ====================
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/mariano/scraping_siped/.venv/bin/python3
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.17.7-arch1-1-x86_64-with-glibc2.42', 'Packages': {'pytest': '8.4.2', 'pluggy': '1.6.0'}, 'Plugins': {'variables': '3.1.0', 'flask': '1.3.0', 'pyfakefs': '5.10.2', 'metadata': '3.1.1', 'html': '4.1.1', 'selenium': '4.1.0', 'base-url': '2.1.0', 'mock': '3.15.1'}, 'Base URL': '', 'Driver': 'Chrome', 'Capabilities': {}}
driver: Chrome
sensitiveurl: .*
rootdir: /home/mariano/scraping_siped
configfile: pytest.ini
plugins: variables-3.1.0, flask-1.3.0, pyfakefs-5.10.2, metadata-3.1.1, html-4.1.1, selenium-4.1.0, base-url-2.1.0, mock-3.15.1
collecting ... collected 24 items

tests/e2e/test_app.py::test_login_get PASSED                             [  4%]
tests/e2e/test_app.py::test_login_post_fallido PASSED                    [  8%]
tests/e2e/test_app.py::test_login_post_exitoso_y_logout PASSED           [ 12%]
tests/e2e/test_app.py::test_rutas_protegidas_sin_login PASSED            [ 16%]
tests/e2e/test_app.py::test_iniciar_fase PASSED                          [ 20%]
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase FAILED      [ 25%]
tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling FAILED [ 29%]
tests/e2e/test_frontend.py::test_race_condition_doble_clic FAILED        [ 33%]
tests/integration/test_fases.py::test_ejecutar_fase_1_exito PASSED       [ 37%]
tests/integration/test_fases.py::test_ejecutar_fase_1_sin_expedientes PASSED [ 41%]
tests/integration/test_fases.py::test_ejecutar_fase_2 PASSED             [ 45%]
tests/integration/test_gestor_almacenamiento.py::test_listar_archivos_pdf PASSED [ 50%]
tests/integration/test_gestor_tareas.py::test_registrar_y_obtener_id PASSED [ 54%]
tests/integration/test_gestor_tareas.py::test_resetear_id_tarea PASSED   [ 58%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_exitosa PASSED [ 62%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_pendiente PASSED [ 66%]
tests/unit/test_parsers.py::test_obtener_url_meta_refresh PASSED         [ 70%]
tests/unit/test_parsers.py::test_obtener_enlace_token_siped PASSED       [ 75%]
tests/unit/test_parsers.py::test_parsear_lista_expedientes PASSED        [ 79%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_inicio PASSED [ 83%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_fin PASSED   [ 87%]
tests/unit/test_parsers.py::test_parsear_detalle_para_ajax_params PASSED [ 91%]
tests/unit/test_parsers.py::test_parsear_movimientos_de_ajax_html PASSED [ 95%]
tests/unit/test_parsers.py::test_parsear_pagina_documento PASSED         [100%]

=================================== FAILURES ===================================
_______________________ test_flujo_login_y_arrancar_fase _______________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="9f3ac7b8805fc587db47b274193eab56")>
live_server = <LiveServer listening at http://localhost:44955>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f09eecf8d60>

    def test_flujo_login_y_arrancar_fase(selenium, live_server, mocker):
        """
        Prueba el flujo completo desde el punto de vista del usuario
        con Selenium.
        """
    
        # --- 1. Mocks (¡Exactamente igual que antes!) ---
        fake_cookies = {"JSESSIONID": "e2e-selenium-test-cookie"}
        mock_auth = mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value=fake_cookies
        )  #
        mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "SUCCESS", "resultado": "IDLE"},
        )  #
        mock_tarea = mocker.Mock(id="fake-celery-task-id-e2e")
        mock_delay = mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
        mocker.patch("app.gestor_tareas.registrar_tarea_iniciada")  #
    
        # --- 2. Ir a la página de Login ---
>       selenium.get(live_server.url_for("login"))  #
                     ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'LiveServer' object has no attribute 'url_for'

tests/e2e/test_frontend.py:34: AttributeError
---------------------------- Captured stdout setup -----------------------------
 * Serving Flask app 'app'
 * Debug mode: off
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-0/test_flujo_login_y_arrancar_fa0/driver.log
URL: data:,
___________________ test_flujo_completo_de_estado_ui_polling ___________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="5686a6e12057d532ae0493b234fff7c4")>
live_server = <LiveServer listening at http://localhost:44955>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f09eecfb820>

    def test_flujo_completo_de_estado_ui_polling(selenium, live_server, mocker):
        """
        Testea el ciclo de vida completo de la UI para una tarea con Selenium:
        IDLE -> PENDING -> SUCCESS -> IDLE
        """
    
        # --- Mocks Iniciales ---
        mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value={"cookie": "123"}
        )  #
        mock_get_estado = mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "SUCCESS", "resultado": "IDLE"},
        )  #
        mock_tarea = mocker.Mock(id="task-123")
        mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
        mocker.patch("app.gestor_tareas.registrar_tarea_iniciada")  #
    
        # --- 1. Cargar la página y verificar estado IDLE ---
>       selenium.get(live_server.url_for("login"))  #
                     ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'LiveServer' object has no attribute 'url_for'

tests/e2e/test_frontend.py:119: AttributeError
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-0/test_flujo_completo_de_estado_0/driver.log
URL: data:,
________________________ test_race_condition_doble_clic ________________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="260349e21bf9c34c1d898be73d21cce6")>
live_server = <LiveServer listening at http://localhost:44955>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f09eeb2a7b0>

    def test_race_condition_doble_clic(selenium, live_server, mocker):
        """
        Testea qué pasa si el usuario hace doble clic muy rápido en 'Iniciar'.
        (Con Selenium, el "doble clic" es más difícil de simular que en
        Playwright, pero podemos hacer dos clics seguidos).
        """
    
        # --- Mocks ---
        mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value={"cookie": "123"}
        )  #
        mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "SUCCESS", "resultado": "IDLE"},
        )  #
        mock_tarea = mocker.Mock(id="task-unico-id")
        mock_delay = mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
    
        # --- Cargar página ---
>       selenium.get(live_server.url_for("login"))  #
                     ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'LiveServer' object has no attribute 'url_for'

tests/e2e/test_frontend.py:215: AttributeError
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-0/test_race_condition_doble_clic0/driver.log
URL: data:,
=========================== short test summary info ============================
FAILED tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase - Attribu...
FAILED tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling
FAILED tests/e2e/test_frontend.py::test_race_condition_doble_clic - Attribute...
========================= 3 failed, 21 passed in 2.19s =========================
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/mariano/scraping_siped/.venv/bin/python3
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.17.7-arch1-1-x86_64-with-glibc2.42', 'Packages': {'pytest': '8.4.2', 'pluggy': '1.6.0'}, 'Plugins': {'variables': '3.1.0', 'flask': '1.3.0', 'pyfakefs': '5.10.2', 'metadata': '3.1.1', 'html': '4.1.1', 'selenium': '4.1.0', 'base-url': '2.1.0', 'mock': '3.15.1'}, 'Base URL': '', 'Driver': 'Chrome', 'Capabilities': {}}
driver: Chrome
sensitiveurl: .*
rootdir: /home/mariano/scraping_siped
configfile: pytest.ini
plugins: variables-3.1.0, flask-1.3.0, pyfakefs-5.10.2, metadata-3.1.1, html-4.1.1, selenium-4.1.0, base-url-2.1.0, mock-3.15.1
collecting ... collected 24 items

tests/e2e/test_app.py::test_login_get PASSED                             [  4%]
tests/e2e/test_app.py::test_login_post_fallido PASSED                    [  8%]
tests/e2e/test_app.py::test_login_post_exitoso_y_logout PASSED           [ 12%]
tests/e2e/test_app.py::test_rutas_protegidas_sin_login PASSED            [ 16%]
tests/e2e/test_app.py::test_iniciar_fase PASSED                          [ 20%]
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase FAILED      [ 25%]
tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling FAILED [ 29%]
tests/e2e/test_frontend.py::test_race_condition_doble_clic FAILED        [ 33%]
tests/integration/test_fases.py::test_ejecutar_fase_1_exito PASSED       [ 37%]
tests/integration/test_fases.py::test_ejecutar_fase_1_sin_expedientes PASSED [ 41%]
tests/integration/test_fases.py::test_ejecutar_fase_2 PASSED             [ 45%]
tests/integration/test_gestor_almacenamiento.py::test_listar_archivos_pdf PASSED [ 50%]
tests/integration/test_gestor_tareas.py::test_registrar_y_obtener_id PASSED [ 54%]
tests/integration/test_gestor_tareas.py::test_resetear_id_tarea PASSED   [ 58%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_exitosa PASSED [ 62%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_pendiente PASSED [ 66%]
tests/unit/test_parsers.py::test_obtener_url_meta_refresh PASSED         [ 70%]
tests/unit/test_parsers.py::test_obtener_enlace_token_siped PASSED       [ 75%]
tests/unit/test_parsers.py::test_parsear_lista_expedientes PASSED        [ 79%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_inicio PASSED [ 83%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_fin PASSED   [ 87%]
tests/unit/test_parsers.py::test_parsear_detalle_para_ajax_params PASSED [ 91%]
tests/unit/test_parsers.py::test_parsear_movimientos_de_ajax_html PASSED [ 95%]
tests/unit/test_parsers.py::test_parsear_pagina_documento PASSED         [100%]

=================================== FAILURES ===================================
_______________________ test_flujo_login_y_arrancar_fase _______________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="6c3b909e982bb63d75b9066663e539e9")>
live_server = <LiveServer listening at http://localhost:41225>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f22d2e0ad70>

    def test_flujo_login_y_arrancar_fase(selenium, live_server, mocker):
        """
        Prueba el flujo completo desde el punto de vista del usuario
        con Selenium.
        """
    
        # --- 1. Mocks (¡Exactamente igual que antes!) ---
        fake_cookies = {"JSESSIONID": "e2e-selenium-test-cookie"}
        mock_auth = mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value=fake_cookies
        )  #
        mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "SUCCESS", "resultado": "IDLE"},
        )  #
        mock_tarea = mocker.Mock(id="fake-celery-task-id-e2e")
        mock_delay = mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
        mocker.patch("app.gestor_tareas.registrar_tarea_iniciada")  #
    
        # --- 2. Ir a la página de Login ---
        # *** CORRECCIÓN AQUÍ ***
>       selenium.get(live_server.url + "/login")  #
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'method' and 'str'

tests/e2e/test_frontend.py:37: TypeError
---------------------------- Captured stdout setup -----------------------------
 * Serving Flask app 'app'
 * Debug mode: off
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-1/test_flujo_login_y_arrancar_fa0/driver.log
URL: data:,
___________________ test_flujo_completo_de_estado_ui_polling ___________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="502ccddc59f6e59aa3f38be5f4b0829c")>
live_server = <LiveServer listening at http://localhost:41225>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f22d2e0b820>

    def test_flujo_completo_de_estado_ui_polling(selenium, live_server, mocker):
        """
        Testea el ciclo de vida completo de la UI para una tarea con Selenium:
        IDLE -> PENDING -> SUCCESS -> IDLE
        """
    
        # --- Mocks Iniciales ---
        mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value={"cookie": "123"}
        )  #
        mock_get_estado = mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "SUCCESS", "resultado": "IDLE"},
        )  #
        mock_tarea = mocker.Mock(id="task-123")
        mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
        mocker.patch("app.gestor_tareas.registrar_tarea_iniciada")  #
    
        # --- 1. Cargar la página y verificar estado IDLE ---
        # *** CORRECCIÓN AQUÍ ***
>       selenium.get(live_server.url + "/login")  #
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'method' and 'str'

tests/e2e/test_frontend.py:120: TypeError
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-1/test_flujo_completo_de_estado_0/driver.log
URL: data:,
________________________ test_race_condition_doble_clic ________________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="7e64dc3aa902a01af7def9472c7c65a8")>
live_server = <LiveServer listening at http://localhost:41225>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f22d2e91130>

    def test_race_condition_doble_clic(selenium, live_server, mocker):
        """
        Testea qué pasa si el usuario hace doble clic muy rápido en 'Iniciar'.
        (Con Selenium, el "doble clic" es más difícil de simular que en
        Playwright, pero podemos hacer dos clics seguidos).
        """
    
        # --- Mocks ---
        mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value={"cookie": "123"}
        )  #
        mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "SUCCESS", "resultado": "IDLE"},
        )  #
        mock_tarea = mocker.Mock(id="task-unico-id")
        mock_delay = mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
    
        # --- Cargar página ---
        # *** CORRECCIÓN AQUÍ ***
>       selenium.get(live_server.url + "/login")  #
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'method' and 'str'

tests/e2e/test_frontend.py:212: TypeError
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-1/test_race_condition_doble_clic0/driver.log
URL: data:,
=========================== short test summary info ============================
FAILED tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase - TypeErr...
FAILED tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling
FAILED tests/e2e/test_frontend.py::test_race_condition_doble_clic - TypeError...
========================= 3 failed, 21 passed in 1.83s =========================
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/mariano/scraping_siped/.venv/bin/python3
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.17.7-arch1-1-x86_64-with-glibc2.42', 'Packages': {'pytest': '8.4.2', 'pluggy': '1.6.0'}, 'Plugins': {'variables': '3.1.0', 'flask': '1.3.0', 'pyfakefs': '5.10.2', 'metadata': '3.1.1', 'html': '4.1.1', 'selenium': '4.1.0', 'base-url': '2.1.0', 'mock': '3.15.1'}, 'Base URL': '', 'Driver': 'Chrome', 'Capabilities': {}}
driver: Chrome
sensitiveurl: .*
rootdir: /home/mariano/scraping_siped
configfile: pytest.ini
plugins: variables-3.1.0, flask-1.3.0, pyfakefs-5.10.2, metadata-3.1.1, html-4.1.1, selenium-4.1.0, base-url-2.1.0, mock-3.15.1
collecting ... collected 24 items

tests/e2e/test_app.py::test_login_get PASSED                             [  4%]
tests/e2e/test_app.py::test_login_post_fallido PASSED                    [  8%]
tests/e2e/test_app.py::test_login_post_exitoso_y_logout PASSED           [ 12%]
tests/e2e/test_app.py::test_rutas_protegidas_sin_login PASSED            [ 16%]
tests/e2e/test_app.py::test_iniciar_fase PASSED                          [ 20%]
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase FAILED      [ 25%]
tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling FAILED [ 29%]
tests/e2e/test_frontend.py::test_race_condition_doble_clic FAILED        [ 33%]
tests/integration/test_fases.py::test_ejecutar_fase_1_exito PASSED       [ 37%]
tests/integration/test_fases.py::test_ejecutar_fase_1_sin_expedientes PASSED [ 41%]
tests/integration/test_fases.py::test_ejecutar_fase_2 PASSED             [ 45%]
tests/integration/test_gestor_almacenamiento.py::test_listar_archivos_pdf PASSED [ 50%]
tests/integration/test_gestor_tareas.py::test_registrar_y_obtener_id PASSED [ 54%]
tests/integration/test_gestor_tareas.py::test_resetear_id_tarea PASSED   [ 58%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_exitosa PASSED [ 62%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_pendiente PASSED [ 66%]
tests/unit/test_parsers.py::test_obtener_url_meta_refresh PASSED         [ 70%]
tests/unit/test_parsers.py::test_obtener_enlace_token_siped PASSED       [ 75%]
tests/unit/test_parsers.py::test_parsear_lista_expedientes PASSED        [ 79%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_inicio PASSED [ 83%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_fin PASSED   [ 87%]
tests/unit/test_parsers.py::test_parsear_detalle_para_ajax_params PASSED [ 91%]
tests/unit/test_parsers.py::test_parsear_movimientos_de_ajax_html PASSED [ 95%]
tests/unit/test_parsers.py::test_parsear_pagina_documento PASSED         [100%]

=================================== FAILURES ===================================
_______________________ test_flujo_login_y_arrancar_fase _______________________

self = <MagicMock name='autenticar_en_siped' id='140567995084352'>
args = ('test_usuario', 'test_password'), kwargs = {}
expected = "autenticar_en_siped('test_usuario', 'test_password')"
actual = 'not called.'
error_message = "expected call not found.\nExpected: autenticar_en_siped('test_usuario', 'test_password')\n  Actual: not called."

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
>           raise AssertionError(error_message)
E           AssertionError: expected call not found.
E           Expected: autenticar_en_siped('test_usuario', 'test_password')
E             Actual: not called.

/usr/lib/python3.13/unittest/mock.py:970: AssertionError

During handling of the above exception, another exception occurred:

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="0326e9b46931e84c8f6225c537c55ebe")>
live_server = <LiveServer listening at http://localhost:34385>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fd88960ad70>

    def test_flujo_login_y_arrancar_fase(selenium, live_server, mocker):
        """
        Prueba el flujo completo desde el punto de vista del usuario
        con Selenium.
        """
    
        # --- 1. Mocks (¡Exactamente igual que antes!) ---
        fake_cookies = {"JSESSIONID": "e2e-selenium-test-cookie"}
        mock_auth = mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value=fake_cookies
        )  #
        mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "SUCCESS", "resultado": "IDLE"},
        )  #
        mock_tarea = mocker.Mock(id="fake-celery-task-id-e2e")
        mock_delay = mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
        mocker.patch("app.gestor_tareas.registrar_tarea_iniciada")  #
    
        # --- 2. Ir a la página de Login ---
        # *** CORRECCIÓN AQUÍ ***
        selenium.get(live_server.url() + "/login")  #
    
        # --- 3. Llenar el formulario y Enviar ---
        # WTForms genera 'id' para los campos, así que usamos By.ID
        selenium.find_element(By.ID, "username").send_keys("test_usuario")
        selenium.find_element(By.ID, "password").send_keys("test_password")
        # El botón 'submit' de WTForms usualmente tiene name="submit"
        selenium.find_element(By.NAME, "submit").click()
    
        # --- 4. Verificar Redirección y Estado ---
    
        # *** CORRECCIÓN AQUÍ ***
        # Esperamos a que la URL cambie al índice (ruta "/")
        WebDriverWait(selenium, timeout=5).until(EC.url_contains(live_server.url() + "/"))
    
        # Verificar que el mock de autenticación fue llamado
>       mock_auth.assert_called_with("test_usuario", "test_password")
E       AssertionError: expected call not found.
E       Expected: autenticar_en_siped('test_usuario', 'test_password')
E         Actual: not called.

tests/e2e/test_frontend.py:51: AssertionError
---------------------------- Captured stdout setup -----------------------------
 * Serving Flask app 'app'
 * Debug mode: off
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-2/test_flujo_login_y_arrancar_fa0/driver.log
URL: http://localhost:34385/login
--------------------------- Captured stdout teardown ---------------------------
Intentando autenticar a test_usuario...
Iniciando sesión como test_usuario...
Error fatal de conexión durante la autenticación: 500 Server Error: Internal Server Error for url: https://intranet.jussantacruz.gob.ar/servicios/controli2.php
___________________ test_flujo_completo_de_estado_ui_polling ___________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="871b5b02b46076eaf5ce6f455dfcad77")>
live_server = <LiveServer listening at http://localhost:34385>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fd88960b5c0>

    def test_flujo_completo_de_estado_ui_polling(selenium, live_server, mocker):
        """
        Testea el ciclo de vida completo de la UI para una tarea con Selenium:
        IDLE -> PENDING -> SUCCESS -> IDLE
        """
    
        # --- Mocks Iniciales ---
        mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value={"cookie": "123"}
        )  #
        mock_get_estado = mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "SUCCESS", "resultado": "IDLE"},
        )  #
        mock_tarea = mocker.Mock(id="task-123")
        mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
        mocker.patch("app.gestor_tareas.registrar_tarea_iniciada")  #
    
        # --- 1. Cargar la página y verificar estado IDLE ---
        # *** CORRECCIÓN AQUÍ ***
        selenium.get(live_server.url() + "/login")  #
        selenium.find_element(By.ID, "username").send_keys("user")
        selenium.find_element(By.ID, "password").send_keys("pass")
        selenium.find_element(By.NAME, "submit").click()
    
        # Esperar a que cargue el índice
        wait = WebDriverWait(selenium, timeout=5)
>       wait.until(
            EC.visibility_of_element_located(
                (By.XPATH, "//*[contains(text(), '¡Bienvenido, user!')]")
            )
        )

tests/e2e/test_frontend.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:129: in until
    value = method(self._driver)
            ^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/selenium/webdriver/support/expected_conditions.py:217: in _predicate
    return _element_if_visible(driver.find_element(*locator))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:926: in find_element
    return self.execute(Command.FIND_ELEMENT, {"using": by, "value": value})["value"]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:458: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7fd889590910>
response = {'status': 404, 'value': '{"value":{"error":"invalid session id","message":"invalid session id: session deleted as the...\\n#18 0x561386e7aee3 \\u003Cunknown>\\n#19 0x7f2b788969cb \\u003Cunknown>\\n#20 0x7f2b7891aa0c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        Args:
            response: The JSON response from the WebDriver server as a dictionary
                object.
    
        Raises:
            WebDriverException: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                try:
                    value = json.loads(value_json)
                    if isinstance(value, dict):
                        if len(value) == 1:
                            value = value["value"]
                        status = value.get("error", None)
                        if not status:
                            status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                            message = value.get("value") or value.get("message")
                            if not isinstance(message, str):
                                value = message
                                message = message.get("message") if isinstance(message, dict) else None
                        else:
                            message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.InvalidSessionIdException: Message: invalid session id: session deleted as the browser has closed the connection
E       from disconnected: not connected to DevTools
E         (Session info: chrome=142.0.7444.134); For documentation on this error, please visit: https://www.selenium.dev/documentation/webdriver/troubleshooting/errors#invalidsessionidexception
E       Stacktrace:
E       #0 0x561386e7c2df <unknown>
E       #1 0x5613868ca11f <unknown>
E       #2 0x5613868b0b5f <unknown>
E       #3 0x5613868d9ccf <unknown>
E       #4 0x56138695048d <unknown>
E       #5 0x56138696957e <unknown>
E       #6 0x561386946943 <unknown>
E       #7 0x561386910541 <unknown>
E       #8 0x561386911272 <unknown>
E       #9 0x561386e45a4e <unknown>
E       #10 0x561386e49027 <unknown>
E       #11 0x561386e48a7a <unknown>
E       #12 0x561386e494c5 <unknown>
E       #13 0x561386e317c3 <unknown>
E       #14 0x561386e498d4 <unknown>
E       #15 0x561386e1a49c <unknown>
E       #16 0x561386e67e67 <unknown>
E       #17 0x561386e680c6 <unknown>
E       #18 0x561386e7aee3 <unknown>
E       #19 0x7f2b788969cb <unknown>
E       #20 0x7f2b7891aa0c <unknown>

.venv/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:233: InvalidSessionIdException
----------------------------- Captured stdout call -----------------------------
Intentando autenticar a user...
Iniciando sesión como user...
Error fatal de conexión durante la autenticación: 500 Server Error: Internal Server Error for url: https://intranet.jussantacruz.gob.ar/servicios/controli2.php
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-2/test_flujo_completo_de_estado_0/driver.log
WARNING: Failed to gather URL: Message: invalid session id; For documentation on this error, please visit: https://www.selenium.dev/documentation/webdriver/troubleshooting/errors#invalidsessionidexception
Stacktrace:
#0 0x561386e7c2df <unknown>
#1 0x5613868c9f6c <unknown>
#2 0x56138690fda3 <unknown>
#3 0x561386946a8a <unknown>
#4 0x561386940f36 <unknown>
#5 0x561386940590 <unknown>
#6 0x561386892a42 <unknown>
#7 0x561386e45a4e <unknown>
#8 0x561386e49027 <unknown>
#9 0x561386e48a7a <unknown>
#10 0x561386e494c5 <unknown>
#11 0x561386e317c3 <unknown>
#12 0x561386e498d4 <unknown>
#13 0x561386e1a49c <unknown>
#14 0x5613868903dc <unknown>
#15 0x56138688f9e0 <unknown>
#16 0x7f2b78827675 <unknown>
#17 0x7f2b78827729 __libc_start_main
#18 0x5613867ae225 _start

WARNING: Failed to gather screenshot: Message: invalid session id; For documentation on this error, please visit: https://www.selenium.dev/documentation/webdriver/troubleshooting/errors#invalidsessionidexception
Stacktrace:
#0 0x561386e7c2df <unknown>
#1 0x5613868c9f6c <unknown>
#2 0x56138690fda3 <unknown>
#3 0x561386946a8a <unknown>
#4 0x561386940f36 <unknown>
#5 0x561386940590 <unknown>
#6 0x561386892a42 <unknown>
#7 0x561386e45a4e <unknown>
#8 0x561386e49027 <unknown>
#9 0x561386e48a7a <unknown>
#10 0x561386e494c5 <unknown>
#11 0x561386e317c3 <unknown>
#12 0x561386e498d4 <unknown>
#13 0x561386e1a49c <unknown>
#14 0x5613868903dc <unknown>
#15 0x56138688f9e0 <unknown>
#16 0x7f2b78827675 <unknown>
#17 0x7f2b78827729 __libc_start_main
#18 0x5613867ae225 _start

WARNING: Failed to gather HTML: Message: invalid session id; For documentation on this error, please visit: https://www.selenium.dev/documentation/webdriver/troubleshooting/errors#invalidsessionidexception
Stacktrace:
#0 0x561386e7c2df <unknown>
#1 0x5613868c9f6c <unknown>
#2 0x56138690fda3 <unknown>
#3 0x561386946a8a <unknown>
#4 0x561386940f36 <unknown>
#5 0x561386940590 <unknown>
#6 0x561386892a42 <unknown>
#7 0x561386e45a4e <unknown>
#8 0x561386e49027 <unknown>
#9 0x561386e48a7a <unknown>
#10 0x561386e494c5 <unknown>
#11 0x561386e317c3 <unknown>
#12 0x561386e498d4 <unknown>
#13 0x561386e1a49c <unknown>
#14 0x5613868903dc <unknown>
#15 0x56138688f9e0 <unknown>
#16 0x7f2b78827675 <unknown>
#17 0x7f2b78827729 __libc_start_main
#18 0x5613867ae225 _start

WARNING: Failed to gather log types: Message: invalid session id; For documentation on this error, please visit: https://www.selenium.dev/documentation/webdriver/troubleshooting/errors#invalidsessionidexception
Stacktrace:
#0 0x561386e7c2df <unknown>
#1 0x5613868c9f6c <unknown>
#2 0x56138690fda3 <unknown>
#3 0x561386946a8a <unknown>
#4 0x561386940f36 <unknown>
#5 0x561386940590 <unknown>
#6 0x561386892a42 <unknown>
#7 0x561386e45a4e <unknown>
#8 0x561386e49027 <unknown>
#9 0x561386e48a7a <unknown>
#10 0x561386e494c5 <unknown>
#11 0x561386e317c3 <unknown>
#12 0x561386e498d4 <unknown>
#13 0x561386e1a49c <unknown>
#14 0x5613868903dc <unknown>
#15 0x56138688f9e0 <unknown>
#16 0x7f2b78827675 <unknown>
#17 0x7f2b78827729 __libc_start_main
#18 0x5613867ae225 _start
________________________ test_race_condition_doble_clic ________________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="29735373eaded7ca0d8938803a9c4fa4")>
live_server = <LiveServer listening at http://localhost:34385>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fd88968d130>

    def test_race_condition_doble_clic(selenium, live_server, mocker):
        """
        Testea qué pasa si el usuario hace doble clic muy rápido en 'Iniciar'.
        (Con Selenium, el "doble clic" es más difícil de simular que en
        Playwright, pero podemos hacer dos clics seguidos).
        """
    
        # --- Mocks ---
        mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value={"cookie": "123"}
        )  #
        mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "SUCCESS", "resultado": "IDLE"},
        )  #
        mock_tarea = mocker.Mock(id="task-unico-id")
        mock_delay = mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
    
        # --- Cargar página ---
        # *** CORRECCIÓN AQUÍ ***
        selenium.get(live_server.url() + "/login")  #
        selenium.find_element(By.ID, "username").send_keys("user")
        selenium.find_element(By.ID, "password").send_keys("pass")
        selenium.find_element(By.NAME, "submit").click()
    
        wait = WebDriverWait(selenium, timeout=5)
>       wait.until(
            EC.visibility_of_element_located((By.XPATH, "//*[contains(text(), 'IDLE')]"))
        )

tests/e2e/test_frontend.py:216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="29735373eaded7ca0d8938803a9c4fa4")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7fd888fa8ae0>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        -----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55f57bf542df <unknown>
E       #1 0x55f57b9a211f <unknown>
E       #2 0x55f57b9f63f1 <unknown>
E       #3 0x55f57b9f67b1 <unknown>
E       #4 0x55f57ba444b5 <unknown>
E       #5 0x55f57ba1ebbd <unknown>
E       #6 0x55f57ba41f18 <unknown>
E       #7 0x55f57ba1e943 <unknown>
E       #8 0x55f57b9e8541 <unknown>
E       #9 0x55f57b9e9272 <unknown>
E       #10 0x55f57bf1da4e <unknown>
E       #11 0x55f57bf21027 <unknown>
E       #12 0x55f57bf20a7a <unknown>
E       #13 0x55f57bf214c5 <unknown>
E       #14 0x55f57bf097c3 <unknown>
E       #15 0x55f57bf218d4 <unknown>
E       #16 0x55f57bef249c <unknown>
E       #17 0x55f57bf3fe67 <unknown>
E       #18 0x55f57bf400c6 <unknown>
E       #19 0x55f57bf52ee3 <unknown>
E       #20 0x7f1fd8a969cb <unknown>
E       #21 0x7f1fd8b1aa0c <unknown>

.venv/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:138: TimeoutException
----------------------------- Captured stdout call -----------------------------
Intentando autenticar a user...
Iniciando sesión como user...
Error fatal de conexión durante la autenticación: 500 Server Error: Internal Server Error for url: https://intranet.jussantacruz.gob.ar/servicios/controli2.php
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-2/test_race_condition_doble_clic0/driver.log
URL: http://localhost:34385/login
=============================== warnings summary ===============================
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase
tests/e2e/test_frontend.py::test_race_condition_doble_clic
  /home/mariano/scraping_siped/.venv/lib/python3.13/site-packages/pytest_selenium/pytest_selenium.py:358: DeprecationWarning: datetime.datetime.utcfromtimestamp() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.fromtimestamp(timestamp, datetime.UTC).
    datetime.utcfromtimestamp(entry["timestamp"] / 1000.0).strftime(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase - Asserti...
FAILED tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling
FAILED tests/e2e/test_frontend.py::test_race_condition_doble_clic - selenium....
================== 3 failed, 21 passed, 2 warnings in 13.71s ===================
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/mariano/scraping_siped/.venv/bin/python3
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.17.7-arch1-1-x86_64-with-glibc2.42', 'Packages': {'pytest': '8.4.2', 'pluggy': '1.6.0'}, 'Plugins': {'variables': '3.1.0', 'flask': '1.3.0', 'pyfakefs': '5.10.2', 'metadata': '3.1.1', 'html': '4.1.1', 'selenium': '4.1.0', 'base-url': '2.1.0', 'mock': '3.15.1'}, 'Base URL': '', 'Driver': 'Chrome', 'Capabilities': {}}
driver: Chrome
sensitiveurl: .*
rootdir: /home/mariano/scraping_siped
configfile: pytest.ini
plugins: variables-3.1.0, flask-1.3.0, pyfakefs-5.10.2, metadata-3.1.1, html-4.1.1, selenium-4.1.0, base-url-2.1.0, mock-3.15.1
collecting ... collected 25 items

tests/e2e/test_app.py::test_login_get PASSED                             [  4%]
tests/e2e/test_app.py::test_login_post_fallido PASSED                    [  8%]
tests/e2e/test_app.py::test_login_post_exitoso_y_logout PASSED           [ 12%]
tests/e2e/test_app.py::test_rutas_protegidas_sin_login PASSED            [ 16%]
tests/e2e/test_app.py::test_iniciar_fase PASSED                          [ 20%]
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase FAILED      [ 24%]
tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling FAILED [ 28%]
tests/e2e/test_frontend.py::test_race_condition_doble_clic FAILED        [ 32%]
tests/integration/test_fases.py::test_ejecutar_fase_1_exito PASSED       [ 36%]
tests/integration/test_fases.py::test_ejecutar_fase_1_sin_expedientes PASSED [ 40%]
tests/integration/test_fases.py::test_ejecutar_fase_2 PASSED             [ 44%]
tests/integration/test_gestor_almacenamiento.py::test_listar_archivos_pdf PASSED [ 48%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_inicial_sin_id PASSED [ 52%]
tests/integration/test_gestor_tareas.py::test_registrar_y_obtener_id PASSED [ 56%]
tests/integration/test_gestor_tareas.py::test_resetear_id_tarea PASSED   [ 60%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_exitosa PASSED [ 64%]
tests/integration/test_gestor_tareas.py::test_obtener_estado_tarea_pendiente PASSED [ 68%]
tests/unit/test_parsers.py::test_obtener_url_meta_refresh PASSED         [ 72%]
tests/unit/test_parsers.py::test_obtener_enlace_token_siped PASSED       [ 76%]
tests/unit/test_parsers.py::test_parsear_lista_expedientes PASSED        [ 80%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_inicio PASSED [ 84%]
tests/unit/test_parsers.py::test_encontrar_siguiente_pagina_fin PASSED   [ 88%]
tests/unit/test_parsers.py::test_parsear_detalle_para_ajax_params PASSED [ 92%]
tests/unit/test_parsers.py::test_parsear_movimientos_de_ajax_html PASSED [ 96%]
tests/unit/test_parsers.py::test_parsear_pagina_documento PASSED         [100%]

=================================== FAILURES ===================================
_______________________ test_flujo_login_y_arrancar_fase _______________________

self = <MagicMock name='autenticar_en_siped' id='139839456981216'>
args = ('test_usuario', 'test_password'), kwargs = {}
expected = "autenticar_en_siped('test_usuario', 'test_password')"
actual = 'not called.'
error_message = "expected call not found.\nExpected: autenticar_en_siped('test_usuario', 'test_password')\n  Actual: not called."

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
>           raise AssertionError(error_message)
E           AssertionError: expected call not found.
E           Expected: autenticar_en_siped('test_usuario', 'test_password')
E             Actual: not called.

/usr/lib/python3.13/unittest/mock.py:970: AssertionError

During handling of the above exception, another exception occurred:

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="0093d31c5901ee731838af6fdfab31a1")>
live_server = <LiveServer listening at http://localhost:42161>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f2ee92055b0>

    def test_flujo_login_y_arrancar_fase(selenium, live_server, mocker):
        """
        Prueba el flujo completo desde el punto de vista del usuario
        con Selenium.
        """
    
        # --- 1. Mocks (¡Exactamente igual que antes!) ---
        fake_cookies = {"JSESSIONID": "e2e-selenium-test-cookie"}
        mock_auth = mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value=fake_cookies
        )  #
        mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "IDLE", "resultado": "En espera"},
        )  #
        mock_tarea = mocker.Mock(id="fake-celery-task-id-e2e")
        mock_delay = mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
        mocker.patch("app.gestor_tareas.registrar_tarea_iniciada")  #
    
        # --- 2. Ir a la página de Login ---
        selenium.get(live_server.url() + "/login")  #
    
        # --- 3. Llenar el formulario y Enviar ---
        # WTForms genera 'id' para los campos, así que usamos By.ID
        selenium.find_element(By.ID, "username").send_keys("test_usuario")
        selenium.find_element(By.ID, "password").send_keys("test_password")
        # El botón 'submit' de WTForms usualmente tiene name="submit"
        selenium.find_element(By.NAME, "submit").click()
    
        # --- 4. Verificar Redirección y Estado ---
    
        # Esperamos a que la URL cambie al índice (ruta "/")
        WebDriverWait(selenium, timeout=5).until(EC.url_contains(live_server.url() + "/"))
    
        # Verificar que el mock de autenticación fue llamado
>       mock_auth.assert_called_with("test_usuario", "test_password")
E       AssertionError: expected call not found.
E       Expected: autenticar_en_siped('test_usuario', 'test_password')
E         Actual: not called.

tests/e2e/test_frontend.py:49: AssertionError
---------------------------- Captured stdout setup -----------------------------
 * Serving Flask app 'app'
 * Debug mode: off
----------------------------- Captured stdout call -----------------------------
Intentando autenticar a test_usuario...
Iniciando sesión como test_usuario...
Error fatal de conexión durante la autenticación: 500 Server Error: Internal Server Error for url: https://intranet.jussantacruz.gob.ar/servicios/controli2.php
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-0/test_flujo_login_y_arrancar_fa0/driver.log
URL: http://localhost:42161/login
___________________ test_flujo_completo_de_estado_ui_polling ___________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="cb5037d728b37ba37770078875a20d8b")>
live_server = <LiveServer listening at http://localhost:42161>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f2ee92076f0>

    def test_flujo_completo_de_estado_ui_polling(selenium, live_server, mocker):
        """
        Testea el ciclo de vida completo de la UI para una tarea con Selenium:
        IDLE -> PENDING -> SUCCESS -> IDLE
        """
    
        # --- Mocks Iniciales ---
        mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value={"cookie": "123"}
        )  #
        mock_get_estado = mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "IDLE", "resultado": "En espera"},
        )  #
        mock_tarea = mocker.Mock(id="task-123")
        mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
        mocker.patch("app.gestor_tareas.registrar_tarea_iniciada")  #
    
        # --- 1. Cargar la página y verificar estado IDLE ---
        selenium.get(live_server.url() + "/login")  #
        selenium.find_element(By.ID, "username").send_keys("user")
        selenium.find_element(By.ID, "password").send_keys("pass")
        selenium.find_element(By.NAME, "submit").click()
    
        # Esperar a que cargue el índice
        wait = WebDriverWait(selenium, timeout=5)
>       wait.until(
            EC.visibility_of_element_located(
                (By.XPATH, "//*[contains(text(), '¡Bienvenido, user!')]")
            )
        )

tests/e2e/test_frontend.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="cb5037d728b37ba37770078875a20d8b")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f2ee9137380>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        -----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55c9041b62df <unknown>
E       #1 0x55c903c0411f <unknown>
E       #2 0x55c903c583f1 <unknown>
E       #3 0x55c903c587b1 <unknown>
E       #4 0x55c903ca64b5 <unknown>
E       #5 0x55c903c80bbd <unknown>
E       #6 0x55c903ca3f18 <unknown>
E       #7 0x55c903c80943 <unknown>
E       #8 0x55c903c4a541 <unknown>
E       #9 0x55c903c4b272 <unknown>
E       #10 0x55c90417fa4e <unknown>
E       #11 0x55c904183027 <unknown>
E       #12 0x55c904182a7a <unknown>
E       #13 0x55c9041834c5 <unknown>
E       #14 0x55c90416b7c3 <unknown>
E       #15 0x55c9041838d4 <unknown>
E       #16 0x55c90415449c <unknown>
E       #17 0x55c9041a1e67 <unknown>
E       #18 0x55c9041a20c6 <unknown>
E       #19 0x55c9041b4ee3 <unknown>
E       #20 0x7fd1086969cb <unknown>
E       #21 0x7fd10871aa0c <unknown>

.venv/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:138: TimeoutException
----------------------------- Captured stdout call -----------------------------
Intentando autenticar a user...
Iniciando sesión como user...
Error fatal de conexión durante la autenticación: 500 Server Error: Internal Server Error for url: https://intranet.jussantacruz.gob.ar/servicios/controli2.php
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-0/test_flujo_completo_de_estado_0/driver.log
URL: http://localhost:42161/login
________________________ test_race_condition_doble_clic ________________________

selenium = <selenium.webdriver.chrome.webdriver.WebDriver (session="bb7a0b8861394376bc131a27ee596c1a")>
live_server = <LiveServer listening at http://localhost:42161>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f2ee929a450>

    def test_race_condition_doble_clic(selenium, live_server, mocker):
        """
        Testea qué pasa si el usuario hace doble clic muy rápido en 'Iniciar'.
        """
    
        # --- Mocks ---
        mocker.patch(
            "app.session_manager.autenticar_en_siped", return_value={"cookie": "123"}
        )  #
        mocker.patch(
            "app.gestor_tareas.obtener_estado_tarea",
            return_value={"estado": "IDLE", "resultado": "En espera"},
        )  #
        mock_tarea = mocker.Mock(id="task-unico-id")
        mock_delay = mocker.patch("app.fase_1_lista_task.delay", return_value=mock_tarea)  #
    
        # --- Cargar página ---
        selenium.get(live_server.url() + "/login")  #
        selenium.find_element(By.ID, "username").send_keys("user")
        selenium.find_element(By.ID, "password").send_keys("pass")
        selenium.find_element(By.NAME, "submit").click()
    
        wait = WebDriverWait(selenium, timeout=5)
    
        # --- INICIO DE LA CORRECCIÓN DEL TEST ---
        # Buscamos el nuevo texto "En espera"
>       wait.until(
            EC.visibility_of_element_located(
                (By.XPATH, "//*[contains(text(), 'En espera')]")
            )
        )

tests/e2e/test_frontend.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="bb7a0b8861394376bc131a27ee596c1a")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f2ee9137560>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        -----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x5653a8d522df <unknown>
E       #1 0x5653a87a011f <unknown>
E       #2 0x5653a87f43f1 <unknown>
E       #3 0x5653a87f47b1 <unknown>
E       #4 0x5653a88424b5 <unknown>
E       #5 0x5653a881cbbd <unknown>
E       #6 0x5653a883ff18 <unknown>
E       #7 0x5653a881c943 <unknown>
E       #8 0x5653a87e6541 <unknown>
E       #9 0x5653a87e7272 <unknown>
E       #10 0x5653a8d1ba4e <unknown>
E       #11 0x5653a8d1f027 <unknown>
E       #12 0x5653a8d1ea7a <unknown>
E       #13 0x5653a8d1f4c5 <unknown>
E       #14 0x5653a8d077c3 <unknown>
E       #15 0x5653a8d1f8d4 <unknown>
E       #16 0x5653a8cf049c <unknown>
E       #17 0x5653a8d3de67 <unknown>
E       #18 0x5653a8d3e0c6 <unknown>
E       #19 0x5653a8d50ee3 <unknown>
E       #20 0x7f562cc969cb <unknown>
E       #21 0x7f562cd1aa0c <unknown>

.venv/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:138: TimeoutException
----------------------------- Captured stdout call -----------------------------
Intentando autenticar a user...
Iniciando sesión como user...
Error fatal de conexión durante la autenticación: 500 Server Error: Internal Server Error for url: https://intranet.jussantacruz.gob.ar/servicios/controli2.php
------------------------------- pytest-selenium --------------------------------
Driver log: /tmp/pytest-of-mariano/pytest-0/test_race_condition_doble_clic0/driver.log
URL: http://localhost:42161/login
=============================== warnings summary ===============================
tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase
tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling
tests/e2e/test_frontend.py::test_race_condition_doble_clic
  /home/mariano/scraping_siped/.venv/lib/python3.13/site-packages/pytest_selenium/pytest_selenium.py:358: DeprecationWarning: datetime.datetime.utcfromtimestamp() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.fromtimestamp(timestamp, datetime.UTC).
    datetime.utcfromtimestamp(entry["timestamp"] / 1000.0).strftime(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/e2e/test_frontend.py::test_flujo_login_y_arrancar_fase - Asserti...
FAILED tests/e2e/test_frontend.py::test_flujo_completo_de_estado_ui_polling
FAILED tests/e2e/test_frontend.py::test_race_condition_doble_clic - selenium....
================== 3 failed, 22 passed, 3 warnings in 13.72s ===================
